<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="Microsoft.VisualStudio.TextTemplating"#>
<#@ output extension=".cs" #>
using System;
using System.Collections.Generic;
using System.Data;
using System.Linq;
using System.Linq.Expressions;
using System.Threading;
using System.Threading.Tasks;

namespace Trolley;

public class Update<TEntity> : IUpdate<TEntity>
{
    #region Properties
    public DbContext DbContext { get; protected set; }
    public IUpdateVisitor Visitor { get; protected set; }
    #endregion

    #region Constructor
    public Update(DbContext dbContext)
    {
        this.DbContext = dbContext;
        this.Visitor = this.DbContext.OrmProvider.NewUpdateVisitor(dbContext.DbKey, dbContext.MapProvider, dbContext.ShardingProvider, dbContext.IsParameterized);
        this.Visitor.Initialize(typeof(TEntity));
    }
    #endregion

    #region Sharding
    public virtual IUpdate<TEntity> UseTable(params string[] tableNames)
    {
        var entityType = typeof(TEntity);
        this.Visitor.UseTable(entityType, tableNames);
        return this;
    }
    public virtual IUpdate<TEntity> UseTable(Func<string, bool> tableNamePredicate)
    {
        var entityType = typeof(TEntity);
        this.Visitor.UseTable(entityType, tableNamePredicate);
        return this;
    }
    public virtual IUpdate<TEntity> UseTableBy(object field1Value, object field2Value = null)
    {
        var entityType = typeof(TEntity);
        this.Visitor.UseTableBy(entityType, field1Value, field2Value);
        return this;
    }
    public virtual IUpdate<TEntity> UseTableByRange(object beginFieldValue, object endFieldValue)
    {
        var entityType = typeof(TEntity);
        this.Visitor.UseTableByRange(entityType, beginFieldValue, endFieldValue);
        return this;
    }
    public virtual IUpdate<TEntity> UseTableByRange(object fieldValue1, object fieldValue2, object fieldValue3)
    {
        var entityType = typeof(TEntity);
        this.Visitor.UseTableByRange(entityType, fieldValue1, fieldValue2, fieldValue3);
        return this;
    }
    #endregion

    #region Set
    public virtual IContinuedUpdate<TEntity> Set<TFields>(TFields setObj)
        => this.Set(true, setObj);
    public virtual IContinuedUpdate<TEntity> Set<TFields>(bool condition, TFields setObj)
    {
        if (setObj == null)
            throw new ArgumentNullException(nameof(setObj));
        if (!typeof(TFields).IsEntityType(out _))
            throw new NotSupportedException("Set方法参数setObj支持实体类对象，不支持基础类型，可以是匿名对、命名对象或是字典");

        if (condition) this.Visitor.SetWith(setObj);
        return this.OrmProvider.NewContinuedUpdate<TEntity>(this.DbContext, this.Visitor);
    }
    public virtual IContinuedUpdate<TEntity> Set<TField>(Expression<Func<TEntity, TField>> fieldSelector, TField fieldValue)
        => this.Set(true, fieldSelector, fieldValue);
    public virtual IContinuedUpdate<TEntity> Set<TField>(bool condition, Expression<Func<TEntity, TField>> fieldSelector, TField fieldValue)
    {
        if (fieldSelector == null)
            throw new ArgumentNullException(nameof(fieldSelector));
        if (fieldValue == null)
            throw new ArgumentNullException(nameof(fieldValue));
        if (fieldSelector.Body.NodeType != ExpressionType.MemberAccess)
            throw new NotSupportedException($"不支持的表达式{nameof(fieldSelector)},只支持MemberAccess类型表达式");

        if (condition) this.Visitor.SetField(fieldSelector, fieldValue);
        return this.OrmProvider.NewContinuedUpdate<TEntity>(this.DbContext, this.Visitor);
    }
    public virtual IContinuedUpdate<TEntity> Set<TFields>(Expression<Func<TEntity, TFields>> fieldsAssignment)
        => this.Set(true, fieldsAssignment);
    public virtual IContinuedUpdate<TEntity> Set<TFields>(bool condition, Expression<Func<TEntity, TFields>> fieldsAssignment)
    {
        if (fieldsAssignment == null)
            throw new ArgumentNullException(nameof(fieldsAssignment));
        if (fieldsAssignment.Body.NodeType != ExpressionType.New && fieldsAssignment.Body.NodeType != ExpressionType.MemberInit)
            throw new NotSupportedException($"不支持的表达式{nameof(fieldsAssignment)},只支持New或MemberInit类型表达式");

        if (condition) this.Visitor.Set(fieldsAssignment);
        return this.OrmProvider.NewContinuedUpdate<TEntity>(this.DbContext, this.Visitor);
    }
    #endregion

    #region SetFrom    
    public virtual IContinuedUpdate<TEntity> SetFrom<TField>(Expression<Func<TEntity, TField>> fieldSelector, Expression<Func<IFromQuery, TEntity, IQuery<TField>>> valueSelector)
        => this.SetFrom(true, fieldSelector, valueSelector);
    public virtual IContinuedUpdate<TEntity> SetFrom<TField>(bool condition, Expression<Func<TEntity, TField>> fieldSelector, Expression<Func<IFromQuery, TEntity, IQuery<TField>>> valueSelector)
    {
        if (fieldSelector == null)
            throw new ArgumentNullException(nameof(fieldSelector));
        if (valueSelector == null)
            throw new ArgumentNullException(nameof(valueSelector));
        if (fieldSelector.Body.NodeType != ExpressionType.MemberAccess)
            throw new NotSupportedException($"不支持的表达式{nameof(fieldSelector)},只支持MemberAccess类型表达式");

        if (condition) this.Visitor.SetFrom(fieldSelector, valueSelector);
        return this.OrmProvider.NewContinuedUpdate<TEntity>(this.DbContext, this.Visitor);
    }
    public virtual IContinuedUpdate<TEntity> SetFrom<TFields>(Expression<Func<IFromQuery, TEntity, TFields>> fieldsAssignment)
        => this.SetFrom(true, fieldsAssignment);
    public virtual IContinuedUpdate<TEntity> SetFrom<TFields>(bool condition, Expression<Func<IFromQuery, TEntity, TFields>> fieldsAssignment)
    {
        if (fieldsAssignment == null)
            throw new ArgumentNullException(nameof(fieldsAssignment));
        if (fieldsAssignment.Body.NodeType != ExpressionType.New && fieldsAssignment.Body.NodeType != ExpressionType.MemberInit)
            throw new NotSupportedException($"不支持的表达式{nameof(fieldsAssignment)},只支持New或MemberInit类型表达式");

        if (condition) this.Visitor.SetFrom(fieldsAssignment);
        return this.OrmProvider.NewContinuedUpdate<TEntity>(this.DbContext, this.Visitor);
    }
    #endregion

    #region SetBulk
    public virtual IContinuedUpdate<TEntity> SetBulk<TUpdateObj>(IEnumerable<TUpdateObj> updateObjs, int bulkCount = 500)
    {
        if (updateObjs == null)
            throw new ArgumentNullException(nameof(updateObjs));

        foreach (var updateObj in updateObjs)
        {
            var updateObjType = updateObj.GetType();
            if (!updateObjType.IsEntityType(out _))
                throw new NotSupportedException("批量更新，单个对象类型只支持匿名对象、命名对象或是字典对象");
            break;
        }
        this.Visitor.SetBulk(updateObjs, bulkCount);
        return this.OrmProvider.NewContinuedUpdate<TEntity>(this.DbContext, this.Visitor);
    }
    #endregion
}
public class Updated<TEntity> : IUpdated<TEntity>
{
    #region Fields
    protected bool hasWhere;
    #endregion

    #region Properties
    public DbContext DbContext { get; protected set; }
    public IUpdateVisitor Visitor { get; protected set; }
    #endregion

    #region Constructor
    public Updated(DbContext dbContext, IUpdateVisitor visitor)
    {
        this.DbContext = dbContext;
        this.Visitor = visitor;
    }
    #endregion

    #region Execute
    public virtual int Execute()
    {
        int result = 0;
        Exception exception = null;
        bool isNeedClose = this.DbContext.IsNeedClose;
        using var command = this.DbContext.CreateCommand();
        try
        {
            switch (this.Visitor.ActionMode)
            {
                case ActionMode.Bulk:
                    result = this.DbContext.UpdateBulk(this.Visitor, command);
                    break;
                default:
                    if (!hasWhere)
                        throw new InvalidOperationException("缺少where条件，请使用Where/And方法完成where条件");

                    var sql = this.Visitor.BuildCommand(command);
                    (var isOpened, sql) = this.DbContext.BuildSql(this.Visitor as SqlVisitor, sql, ";");
                    command.CommandText = sql;
                    if (!isOpened) this.DbContext.Open();
                    result = command.ExecuteNonQuery();
                    break;
            }
        }
        catch (Exception ex)
        {
            isNeedClose = true;
            exception = ex;
        }
        finally
        {
            command.Dispose();
            if (isNeedClose) this.Close();
        }
        if (exception != null) throw exception;
        return result;
    }
    public virtual async Task<int> ExecuteAsync(CancellationToken cancellationToken = default)
    {
        int result = 0;
        Exception exception = null;
        bool isNeedClose = this.DbContext.IsNeedClose;
        using var command = this.DbContext.CreateDbCommand();
        try
        {
            switch (this.Visitor.ActionMode)
            {
                case ActionMode.Bulk:
                    result = await this.DbContext.UpdateBulkAsync(this.Visitor, command, cancellationToken);
                    break;
                default:
                    if (!hasWhere)
                        throw new InvalidOperationException("缺少where条件，请使用Where/And方法完成where条件");

                    var sql = this.Visitor.BuildCommand(command);
                    (var isOpened, sql) = await this.DbContext.BuildSqlAsync(this.Visitor as SqlVisitor, sql, ";", cancellationToken);
                    command.CommandText = sql;
                    if (!isOpened) await this.DbContext.OpenAsync(cancellationToken);
                    result = await command.ExecuteNonQueryAsync(cancellationToken);
                    break;
            }
        }
        catch (Exception ex)
        {
            isNeedClose = true;
            exception = ex;
        }
        finally
        {
            await command.DisposeAsync();
            if (isNeedClose) await this.CloseAsync();
        }
        if (exception != null) throw exception;
        return result;
    }
    #endregion

    #region ToMultipleCommand
    public virtual MultipleCommand ToMultipleCommand() => this.Visitor.CreateMultipleCommand();
    #endregion

    #region ToSql
    public virtual string ToSql(out List<IDbDataParameter> dbParameters)
    {
        string sql = null;
        using var command = this.DbContext.CreateCommand();
        switch (this.Visitor.ActionMode)
        {
            case ActionMode.Bulk:
                sql = this.DbContext.BuildUpdateBulkSql(this.Visitor, command);
                break;
            case ActionMode.Single:
                sql = this.Visitor.BuildCommand(command);
                (_, sql) = this.DbContext.BuildSql(this.Visitor as SqlVisitor, sql, ";");
                break;
        }
        dbParameters = this.Visitor.DbParameters.Cast<IDbDataParameter>().ToList();
        command.Dispose();
        return sql;
    }
    #endregion

    #region Close
    public virtual void Close()
    {
        this.DbContext.Close();
        this.Visitor.Dispose();
        this.Visitor = null;
    }
    public virtual async ValueTask CloseAsync()
    {
        await this.DbContext.CloseAsync();
        this.Visitor.Dispose();
        this.Visitor = null;
    }
    #endregion
}
public class ContinuedUpdate<TEntity> : Updated<TEntity>, IContinuedUpdate<TEntity>
{
    #region Constructor
    public ContinuedUpdate(DbContext dbContext, IUpdateVisitor Visitor)
        : base(dbContext, Visitor) { }
    #endregion

    #region Set
    public virtual IContinuedUpdate<TEntity> Set<TUpdateObj>(TUpdateObj updateObj)
       => this.Set(true, updateObj);
    public virtual IContinuedUpdate<TEntity> Set<TUpdateObj>(bool condition, TUpdateObj updateObj)
    {
        if (updateObj == null)
            throw new ArgumentNullException(nameof(updateObj));

        if (condition) this.Visitor.SetWith(updateObj);
        return this;
    }
    public virtual IContinuedUpdate<TEntity> Set<TField>(Expression<Func<TEntity, TField>> fieldSelector, TField fieldValue)
        => this.Set(true, fieldSelector, fieldValue);
    public virtual IContinuedUpdate<TEntity> Set<TField>(bool condition, Expression<Func<TEntity, TField>> fieldSelector, TField fieldValue)
    {
        if (fieldSelector == null)
            throw new ArgumentNullException(nameof(fieldSelector));
        if (fieldValue == null)
            throw new ArgumentNullException(nameof(fieldValue));
        if (fieldSelector.Body.NodeType != ExpressionType.MemberAccess)
            throw new NotSupportedException($"不支持的表达式{nameof(fieldSelector)},只支持MemberAccess类型表达式");

        if (condition) this.Visitor.SetField(fieldSelector, fieldValue);
        return this;
    }
    public virtual IContinuedUpdate<TEntity> Set<TFields>(Expression<Func<TEntity, TFields>> fieldsAssignment)
       => this.Set(true, fieldsAssignment);
    public virtual IContinuedUpdate<TEntity> Set<TFields>(bool condition, Expression<Func<TEntity, TFields>> fieldsAssignment)
    {
        if (fieldsAssignment == null)
            throw new ArgumentNullException(nameof(fieldsAssignment));
        if (fieldsAssignment.Body.NodeType != ExpressionType.New && fieldsAssignment.Body.NodeType != ExpressionType.MemberInit)
            throw new NotSupportedException($"不支持的表达式{nameof(fieldsAssignment)},只支持New或MemberInit类型表达式");

        if (condition) this.Visitor.Set(fieldsAssignment);
        return this;
    }
    #endregion

    #region SetFrom
    public virtual IContinuedUpdate<TEntity> SetFrom<TField>(Expression<Func<TEntity, TField>> fieldSelector, Expression<Func<IFromQuery, TEntity, IQuery<TField>>> valueSelector)
        => this.SetFrom(true, fieldSelector, valueSelector);
    public virtual IContinuedUpdate<TEntity> SetFrom<TField>(bool condition, Expression<Func<TEntity, TField>> fieldSelector, Expression<Func<IFromQuery, TEntity, IQuery<TField>>> valueSelector)
    {
        if (fieldSelector == null)
            throw new ArgumentNullException(nameof(fieldSelector));
        if (valueSelector == null)
            throw new ArgumentNullException(nameof(valueSelector));
        if (fieldSelector.Body.NodeType != ExpressionType.MemberAccess)
            throw new NotSupportedException($"不支持的表达式{nameof(fieldSelector)},只支持MemberAccess类型表达式");

        if (condition) this.Visitor.SetFrom(fieldSelector, valueSelector);
        return this;
    }
    public virtual IContinuedUpdate<TEntity> SetFrom<TFields>(Expression<Func<IFromQuery, TEntity, TFields>> fieldsAssignment)
        => this.SetFrom(true, fieldsAssignment);
    public virtual IContinuedUpdate<TEntity> SetFrom<TFields>(bool condition, Expression<Func<IFromQuery, TEntity, TFields>> fieldsAssignment)
    {
        if (fieldsAssignment == null)
            throw new ArgumentNullException(nameof(fieldsAssignment));
        if (fieldsAssignment.Body.NodeType != ExpressionType.New && fieldsAssignment.Body.NodeType != ExpressionType.MemberInit)
            throw new NotSupportedException($"不支持的表达式{nameof(fieldsAssignment)},只支持New或MemberInit类型表达式");

        if (condition) this.Visitor.SetFrom(fieldsAssignment);
        return this;
    }
    #endregion

    #region IgnoreFields
    public virtual IContinuedUpdate<TEntity> IgnoreFields(params string[] fieldNames)
    {
        if (fieldNames == null)
            throw new ArgumentNullException(nameof(fieldNames));

        this.Visitor.IgnoreFields(fieldNames);
        return this;
    }
    public virtual IContinuedUpdate<TEntity> IgnoreFields<TFields>(Expression<Func<TEntity, TFields>> fieldsSelector)
    {
        if (fieldsSelector == null)
            throw new ArgumentNullException(nameof(fieldsSelector));
        if (fieldsSelector.Body.NodeType != ExpressionType.MemberAccess && fieldsSelector.Body.NodeType != ExpressionType.New && fieldsSelector.Body.NodeType != ExpressionType.MemberInit)
            throw new NotSupportedException($"不支持的表达式{nameof(fieldsSelector)},只支持MemberAccess、New或MemberInit类型表达式");

        this.Visitor.IgnoreFields(fieldsSelector);
        return this;
    }
    #endregion

    #region OnlyFields
    public virtual IContinuedUpdate<TEntity> OnlyFields(params string[] fieldNames)
    {
        if (fieldNames == null)
            throw new ArgumentNullException(nameof(fieldNames));

        this.Visitor.OnlyFields(fieldNames);
        return this;
    }
    public virtual IContinuedUpdate<TEntity> OnlyFields<TFields>(Expression<Func<TEntity, TFields>> fieldsSelector)
    {
        if (fieldsSelector == null)
            throw new ArgumentNullException(nameof(fieldsSelector));
        if (fieldsSelector.Body.NodeType != ExpressionType.MemberAccess && fieldsSelector.Body.NodeType != ExpressionType.New && fieldsSelector.Body.NodeType != ExpressionType.MemberInit)
            throw new NotSupportedException($"不支持的表达式{nameof(fieldsSelector)},只支持MemberAccess、New或MemberInit类型表达式");

        this.Visitor.OnlyFields(fieldsSelector);
        return this;
    }
    #endregion

    #region Where/And
    public virtual IUpdated<TEntity> Where<TWhereObj>(TWhereObj whereObj)
    {
        if (whereObj == null)
            throw new ArgumentNullException(nameof(whereObj));
        this.Visitor.WhereWith(whereObj);
        this.hasWhere = true;
        return this;
    }
    public virtual IContinuedUpdate<TEntity> Where(Expression<Func<TEntity, bool>> predicate)
        => this.Where(true, predicate);
    public virtual IContinuedUpdate<TEntity> Where(bool condition, Expression<Func<TEntity, bool>> ifPredicate, Expression<Func<TEntity, bool>> elsePredicate = null)
    {
        if (ifPredicate == null)
            throw new ArgumentNullException(nameof(ifPredicate));

        if (condition)
            this.Visitor.Where(ifPredicate);
        else if (elsePredicate != null) this.Visitor.Where(elsePredicate);
        this.hasWhere = true;
        return this;
    }
    public virtual IContinuedUpdate<TEntity> And(Expression<Func<TEntity, bool>> predicate)
        => this.And(true, predicate);
    public virtual IContinuedUpdate<TEntity> And(bool condition, Expression<Func<TEntity, bool>> ifPredicate, Expression<Func<TEntity, bool>> elsePredicate = null)
    {
        if (ifPredicate == null)
            throw new ArgumentNullException(nameof(ifPredicate));

        if (condition)
            this.Visitor.And(ifPredicate);
        else if (elsePredicate != null) this.Visitor.And(elsePredicate);
        return this;
    }
    #endregion
}
<#
    var count = 6;
    var tables = "TEntity";    
    for (int i = 1; i < count; i++)
    {
        tables += $", T{i}";
#>
public class UpdateFrom<<#=tables#>> : Updated<TEntity>, IUpdateFrom<<#=tables#>>
{
    #region Constructor
    public UpdateFrom(DbContext dbContext, IUpdateVisitor visitor)
        : base(dbContext, visitor) { }
    #endregion

    #region Set
    public virtual IUpdateFrom<<#=tables#>> Set<TUpdateObj>(TUpdateObj updateObj)
        => this.Set(true, updateObj);
    public virtual IUpdateFrom<<#=tables#>> Set<TUpdateObj>(bool condition, TUpdateObj updateObj)
    {
        if (updateObj == null)
            throw new ArgumentNullException(nameof(updateObj));
        if (!typeof(TUpdateObj).IsEntityType(out _))
            throw new NotSupportedException("Set方法参数updateObj支持实体类对象，不支持基础类型，可以是匿名对象或是命名对象或是字典");

        if (condition) this.Visitor.SetWith(updateObj);
        return this;
    }    
    public virtual IUpdateFrom<<#=tables#>> Set<TField>(Expression<Func<TEntity, TField>> fieldSelector, TField fieldValue)
        => this.Set(true, fieldSelector, fieldValue);
    public virtual IUpdateFrom<<#=tables#>> Set<TField>(bool condition, Expression<Func<TEntity, TField>> fieldSelector, TField fieldValue)
    {
        if (fieldSelector == null)
            throw new ArgumentNullException(nameof(fieldSelector));
        if (fieldValue == null)
            throw new ArgumentNullException(nameof(fieldValue));
        if (fieldSelector.Body.NodeType != ExpressionType.MemberAccess)
            throw new NotSupportedException($"不支持的表达式{nameof(fieldSelector)},只支持MemberAccess类型表达式");

        if (condition)
            this.Visitor.SetField(fieldSelector, fieldValue);
        return this;
    }
    public virtual IUpdateFrom<<#=tables#>> Set<TFields>(Expression<Func<<#=tables#>, TFields>> fieldsAssignment)
        => this.Set(true, fieldsAssignment);
    public virtual IUpdateFrom<<#=tables#>> Set<TFields>(bool condition, Expression<Func<<#=tables#>, TFields>> fieldsAssignment)
    {
        if (fieldsAssignment == null)
            throw new ArgumentNullException(nameof(fieldsAssignment));
        if (fieldsAssignment.Body.NodeType != ExpressionType.New && fieldsAssignment.Body.NodeType != ExpressionType.MemberInit)
            throw new NotSupportedException($"不支持的表达式{nameof(fieldsAssignment)},只支持New或MemberInit类型表达式");

        if (condition)
            this.Visitor.Set(fieldsAssignment);
        return this;
    }
    #endregion

    #region SetFrom
    public virtual IUpdateFrom<<#=tables#>> SetFrom<TField>(Expression<Func<TEntity, TField>> fieldSelector, Expression<Func<IFromQuery, TEntity, IQuery<TField>>> valueSelector)
        => this.SetFrom(true, fieldSelector, valueSelector);
    public virtual IUpdateFrom<<#=tables#>> SetFrom<TField>(bool condition, Expression<Func<TEntity, TField>> fieldSelector, Expression<Func<IFromQuery, TEntity, IQuery<TField>>> valueSelector)
    {
        if (fieldSelector == null)
            throw new ArgumentNullException(nameof(fieldSelector));
        if (valueSelector == null)
            throw new ArgumentNullException(nameof(valueSelector));
        if (fieldSelector.Body.NodeType != ExpressionType.MemberAccess)
            throw new NotSupportedException($"不支持的表达式{nameof(fieldSelector)},只支持MemberAccess类型表达式");

        if (condition)
            this.Visitor.SetFrom(fieldSelector, valueSelector);
        return this;
    }
    public virtual IUpdateFrom<<#=tables#>> SetFrom<TFields>(Expression<Func<IFromQuery, <#=tables#>, TFields>> fieldsAssignment)
        => this.SetFrom(true, fieldsAssignment);
    public virtual IUpdateFrom<<#=tables#>> SetFrom<TFields>(bool condition, Expression<Func<IFromQuery, <#=tables#>, TFields>> fieldsAssignment)
    {
        if (fieldsAssignment == null)
            throw new ArgumentNullException(nameof(fieldsAssignment));
        if (fieldsAssignment.Body.NodeType != ExpressionType.New && fieldsAssignment.Body.NodeType != ExpressionType.MemberInit)
            throw new NotSupportedException($"不支持的表达式{nameof(fieldsAssignment)},只支持New或MemberInit类型表达式");

        if (condition)
            this.Visitor.SetFrom(fieldsAssignment);
        return this;
    }    
    #endregion

    #region Where/And
    public virtual IUpdateFrom<<#=tables#>> Where(Expression<Func<<#=tables#>, bool>> wherePredicate)
        => this.Where(true, wherePredicate);
    public virtual IUpdateFrom<<#=tables#>> Where(bool condition, Expression<Func<<#=tables#>, bool>> ifPredicate, Expression<Func<<#=tables#>, bool>> elsePredicate = null)
    {
        if (ifPredicate == null)
            throw new ArgumentNullException(nameof(ifPredicate));

        if (condition)
            this.Visitor.Where(ifPredicate);
        else if (elsePredicate != null) this.Visitor.Where(elsePredicate);
        this.hasWhere = true;
        return this;
    }
    public virtual IUpdateFrom<<#=tables#>> And(Expression<Func<<#=tables#>, bool>> andPredicate)
        => this.And(true, andPredicate);
    public virtual IUpdateFrom<<#=tables#>> And(bool condition, Expression<Func<<#=tables#>, bool>> ifPredicate, Expression<Func<<#=tables#>, bool>> elsePredicate = null)
    {
        if (ifPredicate == null)
            throw new ArgumentNullException(nameof(ifPredicate));

        if (condition)
            this.Visitor.And(ifPredicate);
        else if (elsePredicate != null) this.Visitor.And(elsePredicate);
        return this;
    }
    #endregion
}
<#  
    }
    count = 6;
    tables = "TEntity";
    for (int i = 1; i < count; i++)
    {
        tables += $", T{i}";
        var nextTable = $"T{i+1}";
#>
public class UpdateJoin<<#=tables#>> : Updated<TEntity>, IUpdateJoin<<#=tables#>>
{
    #region Constructor
    public UpdateJoin(DbContext dbContext, IUpdateVisitor Visitor)
        : base(dbContext, Visitor) { }
    #endregion

<#
        if(i < count - 1)
        {
#>
    #region Join
    public virtual IUpdateJoin<<#=tables#>, <#=nextTable#>> InnerJoin<<#=nextTable#>>(Expression<Func<<#=tables#>, <#=nextTable#>, bool>> joinOn)
    {
        if (joinOn == null)
            throw new ArgumentNullException(nameof(joinOn));

        this.Visitor.Join("INNER JOIN", typeof(<#=nextTable#>), joinOn);
        return this.OrmProvider.NewUpdateJoin<<#=tables#>, <#=nextTable#>>(this.DbContext, this.Visitor);
    }
    public virtual IUpdateJoin<<#=tables#>, <#=nextTable#>> LeftJoin<<#=nextTable#>>(Expression<Func<<#=tables#>, <#=nextTable#>, bool>> joinOn)
    {
        if (joinOn == null)
            throw new ArgumentNullException(nameof(joinOn));

        this.Visitor.Join("LEFT JOIN", typeof(<#=nextTable#>), joinOn);
        return this.OrmProvider.NewUpdateJoin<<#=tables#>, <#=nextTable#>>(this.DbContext, this.Visitor);
    }
    #endregion

<#      }#>
    #region Set
    public virtual IUpdateJoin<<#=tables#>> Set<TUpdateObj>(TUpdateObj updateObj)
        => this.Set(true, updateObj);
    public virtual IUpdateJoin<<#=tables#>> Set<TUpdateObj>(bool condition, TUpdateObj updateObj)
    {
        if (updateObj == null)
            throw new ArgumentNullException(nameof(updateObj));
        if (!typeof(TUpdateObj).IsEntityType(out _))
            throw new NotSupportedException("Set方法参数updateObj支持实体类对象，不支持基础类型，可以是匿名对象或是命名对象或是字典");

        if (condition) this.Visitor.SetWith(updateObj);
        return this;
    }
    public virtual IUpdateJoin<<#=tables#>> Set<TField>(Expression<Func<TEntity, TField>> fieldSelector, TField fieldValue)
        => this.Set(true, fieldSelector, fieldValue);
    public virtual IUpdateJoin<<#=tables#>> Set<TField>(bool condition, Expression<Func<TEntity, TField>> fieldSelector, TField fieldValue)
    {
        if (fieldSelector == null)
            throw new ArgumentNullException(nameof(fieldSelector));
        if (fieldValue == null)
            throw new ArgumentNullException(nameof(fieldValue));
        if (fieldSelector.Body.NodeType != ExpressionType.MemberAccess)
            throw new NotSupportedException($"不支持的表达式{nameof(fieldSelector)},只支持MemberAccess类型表达式");

        if (condition)
            this.Visitor.SetField(fieldSelector, fieldValue);
        return this;
    }
    public virtual IUpdateJoin<<#=tables#>> Set<TFields>(Expression<Func<<#=tables#>, TFields>> fieldsAssignment)
        => this.Set(true, fieldsAssignment);
    public virtual IUpdateJoin<<#=tables#>> Set<TFields>(bool condition, Expression<Func<<#=tables#>, TFields>> fieldsAssignment)
    {
        if (fieldsAssignment == null)
            throw new ArgumentNullException(nameof(fieldsAssignment));
        if (fieldsAssignment.Body.NodeType != ExpressionType.New && fieldsAssignment.Body.NodeType != ExpressionType.MemberInit)
            throw new NotSupportedException($"不支持的表达式{nameof(fieldsAssignment)},只支持New或MemberInit类型表达式");

        if (condition)
            this.Visitor.Set(fieldsAssignment);
        return this;
    }
    #endregion

    #region SetFrom
    public virtual IUpdateJoin<<#=tables#>> SetFrom<TField>(Expression<Func<TEntity, TField>> fieldSelector, Expression<Func<IFromQuery, TEntity, IQuery<TField>>> valueSelector)
        => this.SetFrom(true, fieldSelector, valueSelector);
    public virtual IUpdateJoin<<#=tables#>> SetFrom<TField>(bool condition, Expression<Func<TEntity, TField>> fieldSelector, Expression<Func<IFromQuery, TEntity, IQuery<TField>>> valueSelector)
    {
        if (fieldSelector == null)
            throw new ArgumentNullException(nameof(fieldSelector));
        if (valueSelector == null)
            throw new ArgumentNullException(nameof(valueSelector));
        if (fieldSelector.Body.NodeType != ExpressionType.MemberAccess)
            throw new NotSupportedException($"不支持的表达式{nameof(fieldSelector)},只支持MemberAccess类型表达式");

        if (condition)
            this.Visitor.SetFrom(fieldSelector, valueSelector);
        return this;
    }
    public virtual IUpdateJoin<<#=tables#>> SetFrom<TFields>(Expression<Func<IFromQuery, <#=tables#>, TFields>> fieldsAssignment)
        => this.SetFrom(true, fieldsAssignment);
    public virtual IUpdateJoin<<#=tables#>> SetFrom<TFields>(bool condition, Expression<Func<IFromQuery, <#=tables#>, TFields>> fieldsAssignment)
    {
        if (fieldsAssignment == null)
            throw new ArgumentNullException(nameof(fieldsAssignment));
        if (fieldsAssignment.Body.NodeType != ExpressionType.New && fieldsAssignment.Body.NodeType != ExpressionType.MemberInit)
            throw new NotSupportedException($"不支持的表达式{nameof(fieldsAssignment)},只支持New或MemberInit类型表达式");

        if (condition)
            this.Visitor.SetFrom(fieldsAssignment);
        return this;
    }
    #endregion

    #region Where/And
    public virtual IUpdateJoin<<#=tables#>> Where(Expression<Func<<#=tables#>, bool>> wherePredicate)
        => this.Where(true, wherePredicate);
    public virtual IUpdateJoin<<#=tables#>> Where(bool condition, Expression<Func<<#=tables#>, bool>> ifPredicate, Expression<Func<<#=tables#>, bool>> elsePredicate = null)
    {
        if (ifPredicate == null)
            throw new ArgumentNullException(nameof(ifPredicate));

        if (condition)
            this.Visitor.Where(ifPredicate);
        else if (elsePredicate != null) this.Visitor.Where(elsePredicate);
        return this;
    }
    public virtual IUpdateJoin<<#=tables#>> And(Expression<Func<<#=tables#>, bool>> andPredicate)
        => this.And(true, andPredicate);
    public virtual IUpdateJoin<<#=tables#>> And(bool condition, Expression<Func<<#=tables#>, bool>> ifPredicate, Expression<Func<<#=tables#>, bool>> elsePredicate = null)
    {
        if (ifPredicate == null)
            throw new ArgumentNullException(nameof(ifPredicate));

        if (condition)
            this.Visitor.And(ifPredicate);
        else if (elsePredicate != null) this.Visitor.And(elsePredicate);
        return this;
    }
    #endregion
}
<#  }#>