<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="Microsoft.VisualStudio.TextTemplating"#>
<#@ output extension=".cs" #>
using System;
using System.Linq.Expressions;

namespace Trolley.SqlServer;

public class SqlServerGroupingCommand<T, TGrouping> : GroupingCommand<T, TGrouping>, ISqlServerGroupingCommand<T, TGrouping>
{
    #region Constructor
    public SqlServerGroupingCommand(DbContext dbContext, IQueryVisitor visitor, ICreateVisitor createVisitor)
        : base(dbContext, visitor, createVisitor) { }
    #endregion

    #region Having
    public override ISqlServerGroupingCommand<T, TGrouping> Having(Expression<Func<IGroupingAggregate<TGrouping>, T, bool>> predicate)
        => this.Having(true, predicate);
    public override ISqlServerGroupingCommand<T, TGrouping> Having(bool condition, Expression<Func<IGroupingAggregate<TGrouping>, T, bool>> predicate)
        => base.Having(condition, predicate) as ISqlServerGroupingCommand<T, TGrouping>;
    #endregion

    #region OrderBy/OrderByDescending
    public override ISqlServerGroupingCommand<T, TGrouping> OrderBy<TFields>(Expression<Func<IGroupingAggregate<TGrouping>, T, TFields>> fieldsExpr)
        => this.OrderBy(true, fieldsExpr);
    public override ISqlServerGroupingCommand<T, TGrouping> OrderBy<TFields>(bool condition, Expression<Func<IGroupingAggregate<TGrouping>, T, TFields>> fieldsExpr)
        => base.OrderBy(condition, fieldsExpr) as ISqlServerGroupingCommand<T, TGrouping>;
    public override ISqlServerGroupingCommand<T, TGrouping> OrderByDescending<TFields>(Expression<Func<IGroupingAggregate<TGrouping>, T, TFields>> fieldsExpr)
        => this.OrderByDescending(true, fieldsExpr);
    public override ISqlServerGroupingCommand<T, TGrouping> OrderByDescending<TFields>(bool condition, Expression<Func<IGroupingAggregate<TGrouping>, T, TFields>> fieldsExpr)
        => base.OrderByDescending(condition, fieldsExpr) as ISqlServerGroupingCommand<T, TGrouping>;
    #endregion

    #region Select
    public override ISqlServerFromCommand<TGrouping> Select()
        => base.Select() as ISqlServerFromCommand<TGrouping>;
    public override ISqlServerFromCommand<TTarget> Select<TTarget>(string fields = "*")
        => base.Select<TTarget>(fields) as ISqlServerFromCommand<TTarget>;
    public override ISqlServerFromCommand<TTarget> Select<TTarget>(Expression<Func<IGroupingAggregate<TGrouping>, T, TTarget>> fieldsExpr)
        => base.Select(fieldsExpr) as ISqlServerFromCommand<TTarget>;
    #endregion
}
<#
    var count = 6;
    var tables = "T1";
    for (int i = 2; i <= count; i++)
    {
        tables += $", T{i}";
#>
public class SqlServerGroupingCommand<<#=tables#>, TGrouping> : GroupingCommand<<#=tables#>, TGrouping>, ISqlServerGroupingCommand<<#=tables#>, TGrouping>
{
    #region Constructor
    public SqlServerGroupingCommand(DbContext dbContext, IQueryVisitor visitor, ICreateVisitor createVisitor)
        : base(dbContext, visitor, createVisitor) { }
    #endregion

    #region Having
    public override ISqlServerGroupingCommand<<#=tables#>, TGrouping> Having(Expression<Func<IGroupingAggregate<TGrouping>, <#=tables#>, bool>> predicate)
        => this.Having(true, predicate);
    public override ISqlServerGroupingCommand<<#=tables#>, TGrouping> Having(bool condition, Expression<Func<IGroupingAggregate<TGrouping>, <#=tables#>, bool>> predicate)
        => base.Having(condition, predicate) as ISqlServerGroupingCommand<<#=tables#>, TGrouping>;
    #endregion

    #region OrderBy/OrderByDescending
    public override ISqlServerGroupingCommand<<#=tables#>, TGrouping> OrderBy<TFields>(Expression<Func<IGroupingAggregate<TGrouping>, <#=tables#>, TFields>> fieldsExpr)
        => this.OrderBy(true, fieldsExpr);
    public override ISqlServerGroupingCommand<<#=tables#>, TGrouping> OrderBy<TFields>(bool condition, Expression<Func<IGroupingAggregate<TGrouping>, <#=tables#>, TFields>> fieldsExpr)
        => base.OrderBy(condition, fieldsExpr) as ISqlServerGroupingCommand<<#=tables#>, TGrouping>;
    public override ISqlServerGroupingCommand<<#=tables#>, TGrouping> OrderByDescending<TFields>(Expression<Func<IGroupingAggregate<TGrouping>, <#=tables#>, TFields>> fieldsExpr)
        => this.OrderByDescending(true, fieldsExpr);
    public override ISqlServerGroupingCommand<<#=tables#>, TGrouping> OrderByDescending<TFields>(bool condition, Expression<Func<IGroupingAggregate<TGrouping>, <#=tables#>, TFields>> fieldsExpr)
        => base.OrderByDescending(condition, fieldsExpr) as ISqlServerGroupingCommand<<#=tables#>, TGrouping>;
    #endregion

    #region Select
    public override ISqlServerFromCommand<TGrouping> Select()
        => base.Select() as ISqlServerFromCommand<TGrouping>;
    public override ISqlServerFromCommand<TTarget> Select<TTarget>(string fields = "*")
        => base.Select<TTarget>(fields) as ISqlServerFromCommand<TTarget>;
    public override ISqlServerFromCommand<TTarget> Select<TTarget>(Expression<Func<IGroupingAggregate<TGrouping>, <#=tables#>, TTarget>> fieldsExpr)
        => base.Select(fieldsExpr) as ISqlServerFromCommand<TTarget>;
    #endregion
}
<#  }#>
public class SqlServerOutputGroupingCommand<T, TGrouping, TResult> : GroupingCommand<T, TGrouping>, ISqlServerOutputGroupingCommand<T, TGrouping, TResult>
{
    #region Constructor
    public SqlServerOutputGroupingCommand(DbContext dbContext, IQueryVisitor visitor, ICreateVisitor createVisitor)
        : base(dbContext, visitor, createVisitor) { }
    #endregion

    #region Having
    public override ISqlServerOutputGroupingCommand<T, TGrouping, TResult> Having(Expression<Func<IGroupingAggregate<TGrouping>, T, bool>> predicate)
        => this.Having(true, predicate);
    public override ISqlServerOutputGroupingCommand<T, TGrouping, TResult> Having(bool condition, Expression<Func<IGroupingAggregate<TGrouping>, T, bool>> predicate)
    {
        base.HavingInternal(condition, predicate);
        return this;
    }
    #endregion

    #region OrderBy/OrderByDescending
    public override ISqlServerOutputGroupingCommand<T, TGrouping, TResult> OrderBy<TFields>(Expression<Func<IGroupingAggregate<TGrouping>, T, TFields>> fieldsExpr)
        => this.OrderBy(true, fieldsExpr);
    public override ISqlServerOutputGroupingCommand<T, TGrouping, TResult> OrderBy<TFields>(bool condition, Expression<Func<IGroupingAggregate<TGrouping>, T, TFields>> fieldsExpr)
    {
        this.OrderByInternal(condition, fieldsExpr);
        return this;
    }
    public override ISqlServerOutputGroupingCommand<T, TGrouping, TResult> OrderByDescending<TFields>(Expression<Func<IGroupingAggregate<TGrouping>, T, TFields>> fieldsExpr)
        => this.OrderByDescending(true, fieldsExpr);
    public override ISqlServerOutputGroupingCommand<T, TGrouping, TResult> OrderByDescending<TFields>(bool condition, Expression<Func<IGroupingAggregate<TGrouping>, T, TFields>> fieldsExpr)
    {
        this.OrderByDescendingInternal(condition, fieldsExpr);
        return this;
    }
    #endregion

    #region Select
    public override ISqlServerOutputFromCommand<TGrouping, TResult> Select()
    {
        this.Visitor.SelectGrouping();
        return new SqlServerOutputFromCommand<TGrouping, TResult>(this.DbContext, this.Visitor, this.CreateVisitor);
    }
    public override ISqlServerOutputFromCommand<TTarget, TResult> Select<TTarget>(string fields = "*")
    {
        base.SelectInternal(fields);
        return new SqlServerOutputFromCommand<TTarget, TResult>(this.DbContext, this.Visitor, this.CreateVisitor);
    }
    public override ISqlServerOutputFromCommand<TTarget, TResult> Select<TTarget>(Expression<Func<IGroupingAggregate<TGrouping>, T, TTarget>> fieldsExpr)
    {
        base.SelectInternal(fieldsExpr);
        return new SqlServerOutputFromCommand<TTarget, TResult>(this.DbContext, this.Visitor, this.CreateVisitor);
    }
    #endregion
}
<#
    tables = "T1";
    for (int i = 2; i <= count; i++)
    {
        tables += $", T{i}";
#>
public class SqlServerOutputGroupingCommand<<#=tables#>, TGrouping, TResult> : GroupingCommand<<#=tables#>, TGrouping>, ISqlServerOutputGroupingCommand<<#=tables#>, TGrouping, TResult>
{
    #region Constructor
    public SqlServerOutputGroupingCommand(DbContext dbContext, IQueryVisitor visitor, ICreateVisitor createVisitor)
        : base(dbContext, visitor, createVisitor) { }
    #endregion

    #region Having
    public override ISqlServerOutputGroupingCommand<<#=tables#>, TGrouping, TResult> Having(Expression<Func<IGroupingAggregate<TGrouping>, <#=tables#>, bool>> predicate)
        => this.Having(true, predicate);
    public override ISqlServerOutputGroupingCommand<<#=tables#>, TGrouping, TResult> Having(bool condition, Expression<Func<IGroupingAggregate<TGrouping>, <#=tables#>, bool>> predicate)
    {
        base.HavingInternal(condition, predicate);
        return this;
    }
    #endregion

    #region OrderBy/OrderByDescending
    public override ISqlServerOutputGroupingCommand<<#=tables#>, TGrouping, TResult> OrderBy<TFields>(Expression<Func<IGroupingAggregate<TGrouping>, <#=tables#>, TFields>> fieldsExpr)
        => this.OrderBy(true, fieldsExpr);
    public override ISqlServerOutputGroupingCommand<<#=tables#>, TGrouping, TResult> OrderBy<TFields>(bool condition, Expression<Func<IGroupingAggregate<TGrouping>, <#=tables#>, TFields>> fieldsExpr)
    {
        base.OrderByInternal(condition, fieldsExpr);
        return this;
    }
    public override ISqlServerOutputGroupingCommand<<#=tables#>, TGrouping, TResult> OrderByDescending<TFields>(Expression<Func<IGroupingAggregate<TGrouping>, <#=tables#>, TFields>> fieldsExpr)
        => this.OrderByDescending(true, fieldsExpr);
    public override ISqlServerOutputGroupingCommand<<#=tables#>, TGrouping, TResult> OrderByDescending<TFields>(bool condition, Expression<Func<IGroupingAggregate<TGrouping>, <#=tables#>, TFields>> fieldsExpr)
    {
        base.OrderByDescendingInternal(condition, fieldsExpr);
        return this;
    }
    #endregion

    #region Select
    public override ISqlServerOutputFromCommand<TGrouping, TResult> Select()
    {
        this.Visitor.SelectGrouping();
        return new SqlServerOutputFromCommand<TGrouping, TResult>(this.DbContext, this.Visitor, this.CreateVisitor);
    }
    public override ISqlServerOutputFromCommand<TTarget, TResult> Select<TTarget>(string fields = "*")
    {
        base.SelectInternal(fields);
        return new SqlServerOutputFromCommand<TTarget, TResult>(this.DbContext, this.Visitor, this.CreateVisitor);
    }
    public override ISqlServerOutputFromCommand<TTarget, TResult> Select<TTarget>(Expression<Func<IGroupingAggregate<TGrouping>, <#=tables#>, TTarget>> fieldsExpr)
    {
        base.SelectInternal(fieldsExpr);
        return new SqlServerOutputFromCommand<TTarget, TResult>(this.DbContext, this.Visitor, this.CreateVisitor);
    }
    #endregion
}
<#  }#>